import { Callout, Tabs, Tab } from 'nextra/components'

# API Reference

Complete API documentation for the MCP Proxy Wrapper and plugin system.

## Core API

### `wrapWithProxy(server, options)`

Wraps an existing MCP server with proxy functionality and plugin support.

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { wrapWithProxy } from 'mcp-proxy-wrapper';

const proxiedServer = await wrapWithProxy(server, {
  plugins: [],
  hooks?: ProxyHooks,
  debug?: boolean
});
```

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `server` | `McpServer` | Yes | MCP server instance to wrap |
| `options.plugins` | `ProxyPlugin[]` | No | Array of plugins to apply |
| `options.hooks` | `ProxyHooks` | No | Before/after tool call hooks |
| `options.debug` | `boolean` | No | Enable debug logging (default: false) |

#### Returns

`Promise<McpServer>` - Enhanced server instance with proxy capabilities

#### Example

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { wrapWithProxy, LLMSummarizationPlugin } from 'mcp-proxy-wrapper';

const summaryPlugin = new LLMSummarizationPlugin();
summaryPlugin.updateConfig({
  options: {
    provider: 'mock', // Use 'openai' with API key for production
    minContentLength: 100,
    summarizeTools: ['search', 'analyze']
  }
});

const server = new McpServer({ name: 'my-server', version: '1.0.0' });
const proxiedServer = await wrapWithProxy(server, {
  plugins: [summaryPlugin],
  debug: true
});
```

### `wrapWithEnhancedProxy(server, options)` (v2 API)

Enhanced version with advanced lifecycle management and performance features.

```typescript
import { wrapWithEnhancedProxy, EnhancedProxyWrapperOptions } from 'mcp-proxy-wrapper';

const proxiedServer = await wrapWithEnhancedProxy(server, {
  plugins: [],
  hooks?: ProxyHooks,
  lifecycle?: LifecycleConfig,
  execution?: ExecutionConfig,
  performance?: PerformanceConfig
});
```

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `server` | `McpServer` | Yes | MCP server instance to wrap |
| `options.plugins` | `ProxyPlugin[]` | No | Array of plugins to apply |
| `options.hooks` | `ProxyHooks` | No | Before/after tool call hooks |
| `options.lifecycle` | `LifecycleConfig` | No | Plugin lifecycle management |
| `options.execution` | `ExecutionConfig` | No | Hook execution configuration |
| `options.performance` | `PerformanceConfig` | No | Performance monitoring |

#### Returns

`Promise<McpServer>` - Enhanced server with v2 proxy capabilities

## Plugin Interface

### `ProxyPlugin`

Base interface that all plugins must implement.

```typescript
interface ProxyPlugin {
  name: string;
  version: string;
  
  // Lifecycle hooks
  beforeToolCall?(context: ToolCallContext): Promise<void | ToolCallResult>;
  afterToolCall?(context: ToolCallContext, result: ToolCallResult): Promise<ToolCallResult>;
  
  // Plugin lifecycle
  initialize?(context: PluginContext): Promise<void>;
  destroy?(): Promise<void>;
}
```

#### Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `name` | `string` | Yes | Unique plugin identifier |
| `version` | `string` | Yes | Plugin version (semver) |

#### Methods

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `beforeToolCall` | `context: ToolCallContext` | `Promise<void \| ToolCallResult>` | Called before tool execution |
| `afterToolCall` | `context: ToolCallContext, result: ToolCallResult` | `Promise<ToolCallResult>` | Called after tool execution |
| `initialize` | `context: PluginContext` | `Promise<void>` | Plugin initialization |
| `destroy` | None | `Promise<void>` | Plugin cleanup |

### `ToolCallContext`

Context object provided to plugin hooks during tool execution.

```typescript
interface ToolCallContext {
  toolName: string;
  args: Record<string, any>;
  metadata: {
    requestId: string;
    timestamp: number;
    userId?: string;
    [key: string]: any;
  };
}
```

#### Properties

| Property | Type | Description |
|----------|------|-------------|
| `toolName` | `string` | Name of the tool being called |
| `args` | `Record<string, any>` | Arguments passed to the tool |
| `metadata.requestId` | `string` | Unique request identifier |
| `metadata.timestamp` | `number` | Request timestamp (Unix milliseconds) |
| `metadata.userId` | `string?` | User identifier (if available) |

### `ToolCallResult`

Result object returned from tool execution.

```typescript
interface ToolCallResult {
  content: Array<{
    type: 'text' | 'image' | 'resource';
    text?: string;
    data?: string;
    url?: string;
    mimeType?: string;
  }>;
  isError?: boolean;
  metadata?: Record<string, any>;
}
```

#### Properties

| Property | Type | Description |
|----------|------|-------------|
| `content` | `Array<ContentBlock>` | Tool response content |
| `isError` | `boolean?` | Indicates if result is an error |
| `metadata` | `Record<string, any>?` | Additional result metadata |

### `PluginContext`

Context provided during plugin initialization.

```typescript
interface PluginContext {
  server: McpServer;
  logger: Logger;
  config: Record<string, any>;
}
```

## Core Plugin APIs

### LLM Summarization Plugin

```typescript
import { LLMSummarizationPlugin } from 'mcp-proxy-wrapper';

const summaryPlugin = new LLMSummarizationPlugin();

// Configuration options
interface SummarizationConfig {
  provider: 'openai' | 'mock';      // AI provider
  openaiApiKey?: string;            // OpenAI API key
  model?: string;                   // Model name (default: gpt-4o-mini)
  maxTokens?: number;               // Max tokens in summary
  temperature?: number;             // Generation temperature
  summarizeTools?: string[];        // Tools to summarize (empty = all)
  minContentLength?: number;        // Min content length to summarize
  saveOriginal?: boolean;           // Save original responses
}

// Update plugin configuration
summaryPlugin.updateConfig({
  options: {
    provider: 'openai',
    openaiApiKey: process.env.OPENAI_API_KEY,
    model: 'gpt-4o-mini',
    maxTokens: 150,
    summarizeTools: ['search', 'research', 'analyze'],
    minContentLength: 100
  }
});

// Get original result by storage key
const original = await summaryPlugin.getOriginalResult(storageKey);

// Get plugin statistics
const stats = await summaryPlugin.getStats();
```

### Chat Memory Plugin

```typescript
import { ChatMemoryPlugin } from 'mcp-proxy-wrapper';

const memoryPlugin = new ChatMemoryPlugin();

// Configuration options
interface MemoryConfig {
  provider: 'openai' | 'mock';      // Chat AI provider
  openaiApiKey?: string;            // OpenAI API key
  model?: string;                   // Model for chat responses
  saveResponses?: boolean;          // Save tool responses
  enableChat?: boolean;             // Enable chat functionality
  maxEntries?: number;              // Max stored entries
  maxSessions?: number;             // Max chat sessions
  sessionTimeout?: number;          // Session timeout in ms
  excludeTools?: string[];          // Tools to exclude from saving
}

// Update plugin configuration
memoryPlugin.updateConfig({
  options: {
    provider: 'openai',
    openaiApiKey: process.env.OPENAI_API_KEY,
    saveResponses: true,
    enableChat: true,
    maxEntries: 1000,
    sessionTimeout: 24 * 60 * 60 * 1000
  }
});

// Start chat session
const sessionId = await memoryPlugin.startChatSession(userId);

// Chat with memory
const response = await memoryPlugin.chatWithMemory(
  sessionId, 
  'What data do I have about sales?', 
  userId
);

// Search conversations
const results = memoryPlugin.searchConversations('sales metrics', userId);

// Get conversation history
const history = memoryPlugin.getConversationHistory(userId, 20);
```

#### Plugin Data Types

```typescript
// LLM Summarization Plugin Types
interface StoredResult {
  originalResult: ToolCallResult;
  context: Omit<PluginContext, 'pluginData'>;
  timestamp: number;
  toolName: string;
  requestId: string;
  metadata?: Record<string, any>;
}

interface LLMProvider {
  generateSummary(content: string, prompt: string, options?: any): Promise<string>;
}

// Chat Memory Plugin Types
interface ConversationEntry {
  id: string;
  toolName: string;
  request: {
    args: Record<string, any>;
    timestamp: number;
  };
  response: {
    content: string;
    metadata?: Record<string, any>;
    timestamp: number;
  };
  context: {
    requestId: string;
    userId?: string;
    sessionId?: string;
  };
}

interface ChatSession {
  id: string;
  userId?: string;
  messages: ChatMessage[];
  createdAt: number;
  lastActivity: number;
}

interface ChatMessage {
  id: string;
  type: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  metadata?: Record<string, any>;
}
```

## Logger Interface

### `Logger`

Standard logging interface used throughout the system.

```typescript
interface Logger {
  debug(message: string, meta?: any): void;
  info(message: string, meta?: any): void;
  warn(message: string, meta?: any): void;
  error(message: string, meta?: any): void;
}
```

#### Default Logger

The proxy wrapper includes a default logger with colored output:

```typescript
import { createLogger } from 'mcp-proxy-wrapper/utils/logger';

const logger = createLogger({
  level: 'info',                       // 'debug' | 'info' | 'warn' | 'error'
  colors: true,                        // Enable colored output
  timestamp: true                      // Include timestamps
});
```

## Error Handling

### Plugin Errors

Plugin errors are automatically caught and logged without breaking tool execution:

```typescript
// Plugin error handling
try {
  await plugin.beforeToolCall(context);
} catch (error) {
  logger.error(`Plugin ${plugin.name} error:`, error);
  // Tool execution continues
}
```

### Tool Errors

Tools should return error results in MCP format:

```typescript
// Tool error response
return {
  content: [{
    type: 'text',
    text: 'Error: Invalid input provided'
  }],
  isError: true
};
```

### Plugin Errors

Plugin errors are handled gracefully by the proxy wrapper:

```typescript
// LLM Summarization error (falls back to original)
return {
  ...result,
  result: {
    ...result.result,
    _meta: {
      ...result.result._meta,
      summarizationError: 'OpenAI API unavailable',
      fallbackToOriginal: true
    }
  }
};

// Chat Memory error (logs but doesn't break tool call)
catch (error) {
  this.logger?.error(`Failed to save conversation entry: ${error}`);
  return result; // Return original result
}
```

## Type Definitions

### Complete TypeScript Definitions

```typescript
// Export all types for use in your applications
export {
  ProxyPlugin,
  BasePlugin,
  ToolCallContext,
  ToolCallResult,
  PluginContext,
  PluginConfig,
  PluginMetadata,
  PluginStats,
  Logger
} from 'mcp-proxy-wrapper';
```

## Migration Guide

### From Direct MCP Server

```typescript
// Before: Direct MCP server
const server = new McpServer(config);
server.tool('my-tool', schema, handler);

// After: Wrapped with proxy
const proxiedServer = await wrapWithProxy(server, { plugins: [] });
proxiedServer.tool('my-tool', schema, handler);
```

### Adding AI Enhancement

```typescript
// Add AI summarization to existing setup
import { LLMSummarizationPlugin } from 'mcp-proxy-wrapper';

const summaryPlugin = new LLMSummarizationPlugin();
summaryPlugin.updateConfig({
  options: {
    provider: 'openai',
    openaiApiKey: process.env.OPENAI_API_KEY,
    summarizeTools: ['research', 'analyze'],
    minContentLength: 200
  }
});

const proxiedServer = await wrapWithProxy(server, {
  plugins: [summaryPlugin]
});
```

<Callout type="info">
  **Backward Compatibility**: The proxy wrapper maintains full compatibility with existing MCP server code. No changes are required to your tool implementations.
</Callout>

## Best Practices

### Plugin Development

1. **Error Isolation**: Always handle errors gracefully
2. **Performance**: Minimize blocking operations in `beforeToolCall`
3. **Logging**: Use structured logging with context
4. **Testing**: Write comprehensive tests for plugin logic

### Production Deployment

1. **Environment Variables**: Use environment-based configuration
2. **Database**: Use PostgreSQL for production data storage
3. **Monitoring**: Implement health checks and alerting
4. **Security**: Follow security best practices for API keys

### Performance Optimization

1. **Plugin Priorities**: Order plugins by execution cost
2. **Caching**: Implement caching for expensive operations
3. **Connection Pooling**: Use connection pooling for databases
4. **Rate Limiting**: Implement appropriate rate limiting

<Callout type="success">
  **Ready to build?** This API reference covers everything you need to integrate the MCP Proxy Wrapper into your applications.
</Callout>
import { Callout, Tabs, Tab, Cards, Card } from 'nextra/components'

# Examples

Real-world implementations showing how to use the MCP Proxy Wrapper in different scenarios.

## Basic AI Service

A simple AI analysis service with logging and caching plugins:

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { wrapWithProxy, LLMSummarizationPlugin, ChatMemoryPlugin } from 'mcp-proxy-wrapper';
import { z } from 'zod';

// Create base server
const server = new McpServer({
  name: 'ai-analysis-service',
  version: '1.0.0'
});

// Configure enhancement plugins
const summaryPlugin = new LLMSummarizationPlugin();
summaryPlugin.updateConfig({
  options: {
    provider: 'mock', // Use 'openai' for production
    summarizeTools: ['sentiment-analysis', 'text-summary'],
    minContentLength: 50
  }
});

const memoryPlugin = new ChatMemoryPlugin();
memoryPlugin.updateConfig({
  options: {
    saveResponses: true,
    maxEntries: 100
  }
});

// Wrap with proxy
const proxiedServer = await wrapWithProxy(server, {
  plugins: [summaryPlugin, memoryPlugin]
});

// Register analysis tools
proxiedServer.tool('sentiment-analysis', {
  text: z.string().min(1, 'Text is required'),
  language: z.string().optional()
}, async (args) => {
  const sentiment = await analyzeSentiment(args.text, args.language);
  
  return {
    content: [{
      type: 'text',
      text: JSON.stringify({
        sentiment: sentiment.label,
        confidence: sentiment.confidence,
        text: args.text
      }, null, 2)
    }]
  };
});

proxiedServer.tool('text-summary', {
  text: z.string().min(10, 'Text must be at least 10 characters'),
  maxLength: z.number().optional().default(100)
}, async (args) => {
  const summary = await generateSummary(args.text, args.maxLength);
  
  return {
    content: [{
      type: 'text', 
      text: summary
    }]
  };
});

// Start server
const transport = new StdioServerTransport();
await proxiedServer.connect(transport);
```

## Multi-Tenant SaaS Platform

A complete SaaS platform with authentication and rate limiting:

```typescript
// Enhanced SaaS platform with AI summarization and memory
const summaryPlugin = new LLMSummarizationPlugin();
summaryPlugin.updateConfig({
  options: {
    provider: 'openai',
    openaiApiKey: process.env.OPENAI_API_KEY,
    model: 'gpt-4o-mini',
    summarizeTools: ['market-analysis', 'competitor-research'],
    minContentLength: 500, // Longer threshold for business data
    saveOriginal: true
  }
});

const memoryPlugin = new ChatMemoryPlugin();
memoryPlugin.updateConfig({
  options: {
    saveResponses: true,
    enableChat: true,
    maxEntries: 5000, // Higher limit for business use
    sessionTimeout: 7 * 24 * 60 * 60 * 1000 // 1 week
  }
});

const proxiedServer = await wrapWithProxy(server, {
  plugins: [memoryPlugin, summaryPlugin] // Memory first, then summarization
});

// Business intelligence tools with AI enhancement
proxiedServer.tool('market-analysis', {
  company: z.string(),
  metrics: z.array(z.string()),
  timeframe: z.enum(['1M', '3M', '6M', '1Y']),
  userId: z.string().optional()
}, async (args) => {
  const analysis = await performMarketAnalysis(args);
  // Plugin automatically summarizes complex analysis data
  return { content: [{ type: 'text', text: JSON.stringify(analysis, null, 2) }] };
});

proxiedServer.tool('competitor-research', {
  industry: z.string(),
  region: z.string().optional(),
  userId: z.string().optional()
}, async (args) => {
  const research = await conductCompetitorResearch(args);
  // Plugin saves research to memory for future reference
  return { content: [{ type: 'text', text: JSON.stringify(research, null, 2) }] };
});
```

## Gaming Platform with Usage Tracking

A gaming service with usage analytics and caching:

```typescript
// Gaming platform with memory and AI summarization
const memoryPlugin = new ChatMemoryPlugin();
memoryPlugin.updateConfig({
  options: {
    saveResponses: true,
    enableChat: true,
    maxEntries: 2000, // Store lots of game sessions
    maxSessions: 500, // Support many concurrent players
    excludeTools: [] // Save all gaming tools
  }
});

const summaryPlugin = new LLMSummarizationPlugin();
summaryPlugin.updateConfig({
  options: {
    provider: 'openai',
    openaiApiKey: process.env.OPENAI_API_KEY,
    summarizeTools: ['ai-dungeon-master'], // Summarize long narrative responses
    minContentLength: 200,
    saveOriginal: true
  }
});

const proxiedServer = await wrapWithProxy(server, {
  plugins: [memoryPlugin, summaryPlugin]
});

// Gaming tools with user tracking
proxiedServer.tool('generate-character', {
  class: z.enum(['warrior', 'mage', 'rogue', 'cleric']),
  level: z.number().min(1).max(20),
  background: z.string().optional(),
  userId: z.string()
}, async (args) => {
  const character = await generateCharacter(args);
  return { content: [{ type: 'text', text: JSON.stringify(character) }] };
});

proxiedServer.tool('ai-dungeon-master', {
  scenario: z.string(),
  playerAction: z.string(),
  context: z.string().optional(),
  userId: z.string()
}, async (args) => {
  const response = await generateDMResponse(args);
  return { content: [{ type: 'text', text: response }] };
});
```

## Development Tools API

A developer-focused API with comprehensive logging and metadata:

```typescript
// Developer tools with AI summarization and memory
const summaryPlugin = new LLMSummarizationPlugin();
summaryPlugin.updateConfig({
  options: {
    provider: 'openai',
    openaiApiKey: process.env.OPENAI_API_KEY,
    summarizeTools: ['code-review', 'security-scan'],
    minContentLength: 300, // Code reviews can be long
    saveOriginal: true
  }
});

const memoryPlugin = new ChatMemoryPlugin();
memoryPlugin.updateConfig({
  options: {
    saveResponses: true,
    enableChat: true,
    maxEntries: 1000,
    sessionTimeout: 2 * 24 * 60 * 60 * 1000 // 2 days for dev work
  }
});

const proxiedServer = await wrapWithProxy(server, {
  plugins: [memoryPlugin, summaryPlugin]
});

// Development tools with AI enhancement
proxiedServer.tool('code-review', {
  code: z.string(),
  language: z.string(),
  focusAreas: z.array(z.enum(['security', 'performance', 'maintainability', 'style'])).optional(),
  userId: z.string().optional()
}, async (args) => {
  const review = await performCodeReview(args);
  // Plugin automatically summarizes detailed code review results
  return { content: [{ type: 'text', text: JSON.stringify(review, null, 2) }] };
});

proxiedServer.tool('security-scan', {
  code: z.string(),
  language: z.string(),
  scanType: z.enum(['static', 'dependency', 'comprehensive']).default('comprehensive'),
  userId: z.string().optional()
}, async (args) => {
  const vulnerabilities = await scanForVulnerabilities(args);
  // Plugin saves scan results to memory for future reference
  return { content: [{ type: 'text', text: JSON.stringify(vulnerabilities, null, 2) }] };
});
```

## Content Platform with Usage Limits

A content creation platform with user tier management:

```typescript
// Content platform with AI summarization and memory
const summaryPlugin = new LLMSummarizationPlugin();
summaryPlugin.updateConfig({
  options: {
    provider: 'openai',
    openaiApiKey: process.env.OPENAI_API_KEY,
    summarizeTools: ['advanced-article'], // Only summarize premium content
    minContentLength: 500,
    saveOriginal: true
  }
});

const memoryPlugin = new ChatMemoryPlugin();
memoryPlugin.updateConfig({
  options: {
    saveResponses: true,
    enableChat: true,
    maxEntries: 3000, // Store lots of content
    sessionTimeout: 30 * 24 * 60 * 60 * 1000, // 30 days for content work
    excludeTools: [] // Save all content creation
  }
});

const proxiedServer = await wrapWithProxy(server, {
  plugins: [memoryPlugin, summaryPlugin]
});

// Content creation tools with user tiers
proxiedServer.tool('simple-blog-post', {
  topic: z.string(),
  tone: z.enum(['professional', 'casual', 'humorous']).default('professional'),
  length: z.enum(['short', 'medium', 'long']).default('medium'),
  userId: z.string()
}, async (args) => {
  const post = await generateBlogPost(args);
  return { content: [{ type: 'text', text: post }] };
});

proxiedServer.tool('advanced-article', {  // Premium only
  topic: z.string(),
  sources: z.array(z.string()),
  seoKeywords: z.array(z.string()),
  targetAudience: z.string(),
  userId: z.string()
}, async (args) => {
  const article = await generateAdvancedArticle(args);
  return { content: [{ type: 'text', text: article }] };
});
```

## Production Configuration Examples

### Environment-Based Setup

```typescript
// config/index.ts
interface Config {
  database: string;
  logLevel: string;
  rateLimits: Record<string, number>;
  cacheSettings: {
    ttl: number;
    maxSize: number;
  };
}

const configs: Record<string, Config> = {
  development: {
    database: 'sqlite:./dev.db',
    logLevel: 'debug',
    rateLimits: {
      'free': 10,
      'premium': 1000
    },
    cacheSettings: {
      ttl: 60000,  // 1 minute for testing
      maxSize: 100
    }
  },
  production: {
    database: process.env.DATABASE_URL!,
    logLevel: 'info',
    rateLimits: {
      'free': 100,
      'premium': 10000,
      'enterprise': 100000
    },
    cacheSettings: {
      ttl: 300000,  // 5 minutes
      maxSize: 10000
    }
  }
};

export const config = configs[process.env.NODE_ENV || 'development'];
```

### Docker Deployment

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY dist/ ./dist/

EXPOSE 3000

CMD ["node", "dist/index.js"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  mcp-server:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:pass@db:5432/mcpserver
      - LOG_LEVEL=info
      - CACHE_TTL=300000
    depends_on:
      - db
  
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: mcpserver
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## Testing Examples

### Integration Testing

```typescript
// tests/integration.test.ts
import { describe, test, expect, beforeEach } from '@jest/globals';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { wrapWithProxy, LLMSummarizationPlugin, ChatMemoryPlugin } from 'mcp-proxy-wrapper';
import { z } from 'zod';

describe('Plugin Integration Tests', () => {
  let proxiedServer: any;
  
  beforeEach(async () => {
    // Create test server with sample tool
    const server = new McpServer('test-server', '1.0.0');
    
    server.tool('test-tool', {
      text: z.string()
    }, async (args) => {
      return {
        content: [{ 
          type: 'text', 
          text: `This is a long response that should be summarized because it exceeds the minimum length: ${args.text}` 
        }]
      };
    });
    
    const summaryPlugin = new LLMSummarizationPlugin();
    summaryPlugin.updateConfig({
      options: {
        provider: 'mock', // Use mock for testing
        minContentLength: 50,
        summarizeTools: ['test-tool']
      }
    });
    
    const memoryPlugin = new ChatMemoryPlugin();
    memoryPlugin.updateConfig({
      options: {
        saveResponses: true,
        maxEntries: 10
      }
    });
    
    proxiedServer = await wrapWithProxy(server, { 
      plugins: [memoryPlugin, summaryPlugin] 
    });
  });

  test('summarizes long responses', async () => {
    const result = await proxiedServer.callTool('test-tool', {
      text: 'This is a long response that should be summarized by the plugin because it exceeds the minimum length threshold for summarization.'
    });
    expect(result.result._meta?.summarized).toBe(true);
    expect(result.result.content[0].text).toContain('Summary:');
  });

  test('saves responses to memory', async () => {
    await proxiedServer.callTool('test-tool', { text: 'Test content', userId: 'user123' });
    
    const memoryPlugin = proxiedServer.plugins.find(p => p.name === 'chat-memory-plugin');
    const history = memoryPlugin.getConversationHistory('user123', 10);
    expect(history.length).toBe(1);
    expect(history[0].response.content).toContain('Test content');
  });
});
```

### Load Testing

```typescript
// tests/load.test.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { wrapWithProxy } from 'mcp-proxy-wrapper';
import { z } from 'zod';

async function loadTest() {
  // Create test server
  const server = new McpServer('load-test-server', '1.0.0');
  
  server.tool('test-tool', {
    data: z.string()
  }, async (args) => {
    return {
      content: [{ type: 'text', text: `Processed: ${args.data}` }]
    };
  });
  
  const proxiedServer = await wrapWithProxy(server, { plugins: [] });
  
  const promises = [];
  const startTime = Date.now();
  
  // Simulate 100 concurrent calls
  for (let i = 0; i < 100; i++) {
    promises.push(proxiedServer.callTool('test-tool', { data: `test-${i}` }));
  }
  
  await Promise.all(promises);
  const duration = Date.now() - startTime;
  
  console.log(`Processed 100 calls in ${duration}ms`);
  console.log(`Average: ${duration / 100}ms per call`);
}
```

## Common Use Cases

<Cards>
  <Card title="AI-as-a-Service" href="#basic-ai-service">
    Monetize AI analysis, generation, and processing tools
  </Card>
  
  <Card title="Developer APIs" href="#development-tools-api">
    Code review, security scanning, and development tools
  </Card>
  
  <Card title="Content Platforms" href="#freemium-content-platform">
    Writing, design, and creative tools with freemium models
  </Card>
  
  <Card title="Enterprise SaaS" href="#multi-tenant-saas-platform">
    Multi-tenant platforms with enhanced functionality
  </Card>
</Cards>

<Callout type="success">
  **Ready to implement?** These examples show real production patterns that you can adapt for your specific use case.
</Callout>

## Next Steps

- **[API Reference](/api-reference)**: Complete API documentation
- **[Deployment](/deployment)**: Production deployment guide
- **[Plugins](/plugins)**: Explore available plugins
- **[Getting Started](/getting-started)**: Basic setup guide
import { Steps, Callout, Tabs, Tab } from 'nextra/components'

# Getting Started

Get up and running with MCP Proxy Wrapper in under 5 minutes. This guide will walk you through installation, basic setup, and your first wrapped MCP server.

## Installation

<Steps>
### Install the Package

```bash
npm install mcp-proxy-wrapper
```

### Verify Installation

```typescript
import { wrapWithProxy } from 'mcp-proxy-wrapper';
console.log('MCP Proxy Wrapper installed successfully!');
```
</Steps>

## Basic Setup

### 1. Create Your MCP Server

First, create a standard MCP server:

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';

const server = new McpServer({
  name: 'My AI Tools Server',
  version: '1.0.0'
});

// Register a simple tool
server.tool('greet', {
  name: z.string(),
  language: z.enum(['en', 'es', 'fr']).optional()
}, async (args) => {
  const greetings = {
    en: `Hello, ${args.name}!`,
    es: `¡Hola, ${args.name}!`,
    fr: `Bonjour, ${args.name}!`
  };
  
  return {
    content: [{
      type: 'text',
      text: greetings[args.language || 'en']
    }]
  };
});
```

### 2. Wrap with Proxy

Transform your server with proxy functionality:

```typescript
import { wrapWithProxy } from 'mcp-proxy-wrapper';

const proxiedServer = await wrapWithProxy(server, {
  debug: true,
  plugins: [
    // Add plugins here
  ]
});
```

### 3. Connect Transport

Connect your server using any MCP transport:

<Tabs items={['STDIO', 'WebSocket', 'SSE', 'InMemory (Testing)']}>
  <Tab>
    ```typescript
    import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
    
    const transport = new StdioServerTransport();
    await proxiedServer.connect(transport);
    
    console.log('MCP server running on STDIO');
    ```
  </Tab>
  <Tab>
    ```typescript
    import { WebSocketServer } from 'ws';
    import { WebSocketServerTransport } from '@modelcontextprotocol/sdk/server/websocket.js';
    
    const wss = new WebSocketServer({ port: 8080 });
    
    wss.on('connection', async (ws) => {
      const transport = new WebSocketServerTransport(ws);
      await proxiedServer.connect(transport);
      console.log('New WebSocket connection');
    });
    
    console.log('MCP server running on WebSocket :8080');
    ```
  </Tab>
  <Tab>
    ```typescript
    import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
    import express from 'express';
    
    const app = express();
    const transport = new SSEServerTransport('/api/sse', proxiedServer);
    
    app.use('/api/sse', transport.createHandler());
    app.listen(3000);
    
    console.log('MCP server running on SSE :3000/api/sse');
    ```
  </Tab>
  <Tab>
    ```typescript
    import { InMemoryTransport } from '@modelcontextprotocol/sdk/inMemory.js';
    
    const [serverTransport, clientTransport] = InMemoryTransport.createLinkedPair();
    await proxiedServer.connect(serverTransport);
    
    // Use clientTransport for testing
    console.log('MCP server running in-memory for testing');
    ```
  </Tab>
</Tabs>

## Complete Example

Here's a complete working example:

```typescript
// server.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { wrapWithProxy } from 'mcp-proxy-wrapper';
import { z } from 'zod';

async function main() {
  // 1. Create MCP server
  const server = new McpServer({
    name: 'Enhanced AI Tools',
    version: '1.0.0'
  });

  // 2. Wrap with proxy
  const proxiedServer = await wrapWithProxy(server, {
    debug: true
  });

  // 3. Register tools
  proxiedServer.tool('calculate', {
    expression: z.string(),
    precision: z.number().optional()
  }, async (args) => {
    try {
      // Simple calculator (be careful with eval in production!)
      const result = eval(args.expression);
      const precision = args.precision || 2;
      
      return {
        content: [{
          type: 'text',
          text: `${args.expression} = ${result.toFixed(precision)}`
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `Error: Invalid expression "${args.expression}"`
        }],
        isError: true
      };
    }
  });

  proxiedServer.tool('timestamp', {
    format: z.enum(['iso', 'unix', 'human']).optional()
  }, async (args) => {
    const now = new Date();
    const formats = {
      iso: now.toISOString(),
      unix: Math.floor(now.getTime() / 1000).toString(),
      human: now.toLocaleString()
    };
    
    return {
      content: [{
        type: 'text',
        text: formats[args.format || 'iso']
      }]
    };
  });

  // 4. Connect transport
  const transport = new StdioServerTransport();
  await proxiedServer.connect(transport);

  console.error('✅ Enhanced MCP server is running!');
  console.error('📝 Available tools: calculate, timestamp');
  console.error('🔌 Transport: STDIO');
}

main().catch(console.error);
```

Run it:

```bash
npx tsx server.ts
```

## Adding Your First Plugin

Let's add logging to see what's happening:

```typescript
import { BasePlugin } from 'mcp-proxy-wrapper';

class LoggingPlugin extends BasePlugin {
  name = 'logging-plugin';
  version = '1.0.0';

  async beforeToolCall(context) {
    console.log(`🔧 Calling tool: ${context.toolName}`);
    console.log(`📝 Arguments:`, context.args);
    console.log(`🆔 Request ID: ${context.metadata.requestId}`);
    
    // Don't block the call - just log
    return undefined;
  }

  async afterToolCall(context, result) {
    console.log(`✅ Tool completed: ${context.toolName}`);
    console.log(`📊 Success: ${!result.isError}`);
    
    // Add timing metadata
    result.result._meta = {
      ...result.result._meta,
      processedAt: new Date().toISOString(),
      plugin: this.name
    };
    
    return result;
  }
}

// Add to your server
const proxiedServer = await wrapWithProxy(server, {
  plugins: [new LoggingPlugin()]
});
```

## Testing Your Server

### With MCP Client

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

const client = new Client({
  name: 'Test Client',
  version: '1.0.0'
}, { capabilities: {} });

const transport = new StdioClientTransport({
  command: 'node',
  args: ['server.js']
});

await client.connect(transport);

// Test your tools
const result = await client.callTool({
  name: 'calculate',
  arguments: { expression: '2 + 2' }
});

console.log(result.content[0].text); // "2 + 2 = 4.00"
```

### Quick Test Script

```typescript
// test.ts
import { InMemoryTransport } from '@modelcontextprotocol/sdk/inMemory.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';

async function testServer() {
  // Create linked transports
  const [serverTransport, clientTransport] = InMemoryTransport.createLinkedPair();
  
  // Connect server
  await proxiedServer.connect(serverTransport);
  
  // Connect client
  const client = new Client({
    name: 'Test Client',
    version: '1.0.0'
  }, { capabilities: {} });
  
  await client.connect(clientTransport);
  
  // Test tools
  const tests = [
    { name: 'calculate', arguments: { expression: '10 * 5' } },
    { name: 'timestamp', arguments: { format: 'human' } },
    { name: 'greet', arguments: { name: 'World', language: 'en' } }
  ];
  
  for (const test of tests) {
    try {
      const result = await client.callTool(test);
      console.log(`✅ ${test.name}:`, result.content[0].text);
    } catch (error) {
      console.log(`❌ ${test.name}:`, error.message);
    }
  }
}

testServer().catch(console.error);
```

## Configuration Options

### Debug Mode

Enable detailed logging:

```typescript
const proxiedServer = await wrapWithProxy(server, {
  debug: true,
  logger: {
    level: 'debug',
    prefix: 'MY-SERVER'
  }
});
```

### Plugin Options

```typescript
const proxiedServer = await wrapWithProxy(server, {
  plugins: [
    { plugin: new MyPlugin(), priority: 100 },
    { plugin: new AnotherPlugin(), priority: 200 }
  ],
  timeout: 30000, // 30 second timeout
  maxRetries: 3
});
```

### Error Handling

```typescript
const proxiedServer = await wrapWithProxy(server, {
  onError: (error, context) => {
    console.error(`Error in ${context.toolName}:`, error);
    // Custom error handling
  },
  plugins: [myPlugin]
});
```

## Next Steps

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <div className="p-4 border rounded-lg">
    <h3 className="text-lg font-semibold mb-2">🔌 Add Plugins</h3>
    <p className="text-sm text-gray-600 mb-3">Enhance your server with monetization, analytics, and security.</p>
    <a href="/plugins" className="text-blue-600 hover:text-blue-800">Explore plugins →</a>
  </div>
  
  <div className="p-4 border rounded-lg">
    <h3 className="text-lg font-semibold mb-2">💰 Monetize</h3>
    <p className="text-sm text-gray-600 mb-3">Start earning revenue with the Stripe monetization plugin.</p>
    <a href="/plugins/stripe-monetization" className="text-blue-600 hover:text-blue-800">Add billing →</a>
  </div>
  
  <div className="p-4 border rounded-lg">
    <h3 className="text-lg font-semibold mb-2">🚀 Deploy</h3>
    <p className="text-sm text-gray-600 mb-3">Deploy your enhanced server to production.</p>
    <a href="/deployment" className="text-blue-600 hover:text-blue-800">Deploy guide →</a>
  </div>
  
  <div className="p-4 border rounded-lg">
    <h3 className="text-lg font-semibold mb-2">📚 Examples</h3>
    <p className="text-sm text-gray-600 mb-3">See real-world examples and use cases.</p>
    <a href="/examples" className="text-blue-600 hover:text-blue-800">View examples →</a>
  </div>
</div>

<Callout type="success">
  **Congratulations!** You now have a working MCP server enhanced with proxy wrapper functionality. Ready to add some powerful plugins?
</Callout>